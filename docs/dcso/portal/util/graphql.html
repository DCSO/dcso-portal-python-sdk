<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>dcso.portal.util.graphql API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dcso.portal.util.graphql</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2020, DCSO GmbH

import json
import ssl
from collections import namedtuple
from datetime import datetime, timezone
from os import environ
from typing import AnyStr, List, Optional, Union
from urllib.error import URLError
from urllib.parse import ParseResult, urlparse
from urllib.request import Request, urlopen

from dcso.glosom import Glosom
from ..exceptions import PortalAPIError, PortalAPIRequest
from ..util.temporal import decode_utc_iso8601

_ENV_SKIP_TLS_VERIFY = &#34;DCSO_PORTAL_SKIP_TLS_VERIFY&#34;


class GraphQLJSONEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, datetime):
            return o.replace(tzinfo=timezone.utc).isoformat()

        return super().default(o)


class GraphQLJSONDecoder(json.JSONDecoder):
    def __init__(self, *args, **kwargs):
        try:
            del kwargs[&#39;object_hook&#39;]
        except KeyError:
            # ok when not in kwargs
            pass
        super().__init__(*args, **kwargs, object_hook=self.object_hook)

    @staticmethod
    def object_hook(o: dict) -&gt; dict:
        for k, v in o.items():
            try:
                o[k] = decode_utc_iso8601(v)
            except ValueError as exc:
                # not an ISO date formatted string; let others figure it out
                pass

        return o


class GraphQLRequest:
    def __init__(self,
                 query: str,
                 api_url: Union[ParseResult, str],
                 variables: Optional[dict] = None,
                 fragments: Optional[List[str]] = None,
                 token: Optional[str] = None):
        self.query: str = query
        self.api_url: Union[ParseResult, str] = api_url
        self.variables: dict = variables
        self.fragments: List[str] = fragments
        self.token: Optional[str] = token

    def json(self) -&gt; bytes:
        q = self.query
        if self.fragments:
            q += &#39;\n&#39;.join(self.fragments)

        r = {
            &#39;query&#39;: q
        }

        if self.variables:
            r[&#39;variables&#39;] = self.variables

        return json.dumps(r, cls=GraphQLJSONEncoder).encode(&#39;utf-8&#39;)

    def execute_raw(self) -&gt; AnyStr:
        &#34;&#34;&#34;Executes the GraphQL query and return the response from the wire as JSON.

        This method is not to be used directly unless JSON must be process different.
        Methods `execute_dict` and `execute` have a more Pythonic result, and easier
        to use.

        Raises PortalAPIRequest when request with API or decoding result fails.
        &#34;&#34;&#34;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }

        if self.token:
            headers[&#39;Authorization&#39;] = &#39;Bearer &#39; + self.token

        url = self.api_url
        if isinstance(url, str):
            url = urlparse(self.api_url)

        req = Request(url.geturl(), headers=headers, method=&#39;POST&#39;, data=self.json())

        ssl_ctx = None
        if url.scheme == &#39;https&#39;:
            ssl_ctx = ssl.SSLContext()
            if environ.get(_ENV_SKIP_TLS_VERIFY):
                ssl_ctx.verify_mode = ssl.CERT_NONE

        try:
            return urlopen(req, context=ssl_ctx).read()
        except URLError as exc:
            raise PortalAPIRequest(str(exc.reason))

    def execute_dict(self) -&gt; dict:
        &#34;&#34;&#34;Executes the GraphQL request returning response as a dictionary.

        Raises `PortalAPIError` When the GraphQL API endpoint returned an error.
        When there was an issue with the request itself, or decoding JSON failed,
        the `PortalAPIRequest` exception is raised.
        &#34;&#34;&#34;
        res = self.execute_raw()
        if isinstance(res, bytes):
            res = res.decode(&#39;utf-8&#39;)

        try:
            response = json.loads(res, cls=GraphQLJSONDecoder)
        except json.JSONDecodeError as exc:
            raise PortalAPIRequest(&#34;failed decoding API response: &#34; + str(exc))

        try:
            first_error = response[&#39;errors&#39;][0]
        except (TypeError, KeyError, IndexError):
            # all is good; return response
            return response

        try:
            err = first_error[&#39;message&#39;]
            code = &#34;&#34;
            if &#39;extensions&#39; in first_error:
                if &#39;detail&#39; in first_error[&#39;extensions&#39;]:
                    err += &#39; (&#39; + first_error[&#39;extensions&#39;][&#39;detail&#39;] + &#39;)&#39;
                code = first_error[&#39;extensions&#39;].get(&#39;code&#39;, &#34;&#34;)
            g = Glosom(message=first_error[&#39;message&#39;], code=code)
        except KeyError as exc:
            raise PortalAPIRequest(f&#34;API request contained unusable error definition {exc}&#34;)
        except AttributeError:
            raise PortalAPIRequest(f&#34;API request contained unusable error extensions&#34;)
        else:
            raise PortalAPIError(glosom=g)

    def execute(self) -&gt; namedtuple:
        &#34;&#34;&#34;Executes the GraphQL request returning response as a namedtuple.

        This method wraps around the `execute` method, but returns instead of
        dict, a namedtuple which itself might contain namedtuples.

        Raises `PortalAPIError` When the GraphQL API endpoint returned an error.
        When there was an issue with the request itself, or decoding JSON failed,
        the `PortalAPIRequest` exception is raised.
        &#34;&#34;&#34;
        return graphql_data_to_namedtuple(self.execute_dict()[&#39;data&#39;])


def graphql_data_to_namedtuple(mapping: dict, name: str = &#39;data&#39;) -&gt; namedtuple:
    &#34;&#34;&#34;Transforms GraphQL response data and returns it as a namedtuple.

    This method takes the mapping as GraphQL Response data and recursively goes
    through it converting dict object to namedtuple, and array of objects as list.

    The name of the namedtuple is the key of value it is created from. The
    starting named tuple is by default called &#39;data&#39;.
    &#34;&#34;&#34;
    if isinstance(mapping, dict):
        for key, value in mapping.items():
            if isinstance(value, (list, tuple)):
                for idx, p in enumerate(value):
                    value[idx] = graphql_data_to_namedtuple(p, key)
            else:
                mapping[key] = graphql_data_to_namedtuple(value, key)
        return namedtuple(name, field_names=mapping.keys())(*mapping.values())
    return mapping</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dcso.portal.util.graphql.graphql_data_to_namedtuple"><code class="name flex">
<span>def <span class="ident">graphql_data_to_namedtuple</span></span>(<span>mapping: dict, name: str = 'data') ‑> <function namedtuple at 0x7fc607fdb830></span>
</code></dt>
<dd>
<div class="desc"><p>Transforms GraphQL response data and returns it as a namedtuple.</p>
<p>This method takes the mapping as GraphQL Response data and recursively goes
through it converting dict object to namedtuple, and array of objects as list.</p>
<p>The name of the namedtuple is the key of value it is created from. The
starting named tuple is by default called 'data'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graphql_data_to_namedtuple(mapping: dict, name: str = &#39;data&#39;) -&gt; namedtuple:
    &#34;&#34;&#34;Transforms GraphQL response data and returns it as a namedtuple.

    This method takes the mapping as GraphQL Response data and recursively goes
    through it converting dict object to namedtuple, and array of objects as list.

    The name of the namedtuple is the key of value it is created from. The
    starting named tuple is by default called &#39;data&#39;.
    &#34;&#34;&#34;
    if isinstance(mapping, dict):
        for key, value in mapping.items():
            if isinstance(value, (list, tuple)):
                for idx, p in enumerate(value):
                    value[idx] = graphql_data_to_namedtuple(p, key)
            else:
                mapping[key] = graphql_data_to_namedtuple(value, key)
        return namedtuple(name, field_names=mapping.keys())(*mapping.values())
    return mapping</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dcso.portal.util.graphql.GraphQLJSONDecoder"><code class="flex name class">
<span>class <span class="ident">GraphQLJSONDecoder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple JSON <a href="http://json.org">http://json.org</a> decoder</p>
<p>Performs the following translations in decoding by default:</p>
<p>+---------------+-------------------+
| JSON
| Python
|
+===============+===================+
| object
| dict
|
+---------------+-------------------+
| array
| list
|
+---------------+-------------------+
| string
| str
|
+---------------+-------------------+
| number (int)
| int
|
+---------------+-------------------+
| number (real) | float
|
+---------------+-------------------+
| true
| True
|
+---------------+-------------------+
| false
| False
|
+---------------+-------------------+
| null
| None
|
+---------------+-------------------+</p>
<p>It also understands <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> as
their corresponding <code>float</code> values, which is outside the JSON spec.</p>
<p><code>object_hook</code>, if specified, will be called with the result
of every JSON object decoded and its return value will be used in
place of the given <code>dict</code>.
This can be used to provide custom
deserializations (e.g. to support JSON-RPC class hinting).</p>
<p><code>object_pairs_hook</code>, if specified will be called with the result of
every JSON object decoded with an ordered list of pairs.
The return
value of <code>object_pairs_hook</code> will be used instead of the <code>dict</code>.
This feature can be used to implement custom decoders.
If <code>object_hook</code> is also defined, the <code>object_pairs_hook</code> takes
priority.</p>
<p><code>parse_float</code>, if specified, will be called with the string
of every JSON float to be decoded. By default this is equivalent to
float(num_str). This can be used to use another datatype or parser
for JSON floats (e.g. decimal.Decimal).</p>
<p><code>parse_int</code>, if specified, will be called with the string
of every JSON int to be decoded. By default this is equivalent to
int(num_str). This can be used to use another datatype or parser
for JSON integers (e.g. float).</p>
<p><code>parse_constant</code>, if specified, will be called with one of the
following strings: -Infinity, Infinity, NaN.
This can be used to raise an exception if invalid JSON numbers
are encountered.</p>
<p>If <code>strict</code> is false (true is the default), then control
characters will be allowed inside strings.
Control characters in
this context are those with character codes in the 0-31 range,
including <code>'\t'</code> (tab), <code>'\n'</code>, <code>'\r'</code> and <code>'\0'</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphQLJSONDecoder(json.JSONDecoder):
    def __init__(self, *args, **kwargs):
        try:
            del kwargs[&#39;object_hook&#39;]
        except KeyError:
            # ok when not in kwargs
            pass
        super().__init__(*args, **kwargs, object_hook=self.object_hook)

    @staticmethod
    def object_hook(o: dict) -&gt; dict:
        for k, v in o.items():
            try:
                o[k] = decode_utc_iso8601(v)
            except ValueError as exc:
                # not an ISO date formatted string; let others figure it out
                pass

        return o</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.decoder.JSONDecoder</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dcso.portal.util.graphql.GraphQLJSONDecoder.object_hook"><code class="name flex">
<span>def <span class="ident">object_hook</span></span>(<span>o: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def object_hook(o: dict) -&gt; dict:
    for k, v in o.items():
        try:
            o[k] = decode_utc_iso8601(v)
        except ValueError as exc:
            # not an ISO date formatted string; let others figure it out
            pass

    return o</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dcso.portal.util.graphql.GraphQLJSONEncoder"><code class="flex name class">
<span>class <span class="ident">GraphQLJSONEncoder</span></span>
<span>(</span><span>*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python
| JSON
|
+===================+===============+
| dict
| object
|
+-------------------+---------------+
| list, tuple
| array
|
+-------------------+---------------+
| str
| string
|
+-------------------+---------------+
| int, float
| number
|
+-------------------+---------------+
| True
| true
|
+-------------------+---------------+
| False
| false
|
+-------------------+---------------+
| None
| null
|
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float or None.
If
skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an OverflowError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphQLJSONEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, datetime):
            return o.replace(tzinfo=timezone.utc).isoformat()

        return super().default(o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dcso.portal.util.graphql.GraphQLJSONEncoder.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, o)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    # Let the base class default method raise the TypeError
    return JSONEncoder.default(self, o)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(self, o):
    if isinstance(o, datetime):
        return o.replace(tzinfo=timezone.utc).isoformat()

    return super().default(o)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dcso.portal.util.graphql.GraphQLRequest"><code class="flex name class">
<span>class <span class="ident">GraphQLRequest</span></span>
<span>(</span><span>query: str, api_url: Union[urllib.parse.ParseResult, str], variables: Union[dict, NoneType] = None, fragments: Union[List[str], NoneType] = None, token: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphQLRequest:
    def __init__(self,
                 query: str,
                 api_url: Union[ParseResult, str],
                 variables: Optional[dict] = None,
                 fragments: Optional[List[str]] = None,
                 token: Optional[str] = None):
        self.query: str = query
        self.api_url: Union[ParseResult, str] = api_url
        self.variables: dict = variables
        self.fragments: List[str] = fragments
        self.token: Optional[str] = token

    def json(self) -&gt; bytes:
        q = self.query
        if self.fragments:
            q += &#39;\n&#39;.join(self.fragments)

        r = {
            &#39;query&#39;: q
        }

        if self.variables:
            r[&#39;variables&#39;] = self.variables

        return json.dumps(r, cls=GraphQLJSONEncoder).encode(&#39;utf-8&#39;)

    def execute_raw(self) -&gt; AnyStr:
        &#34;&#34;&#34;Executes the GraphQL query and return the response from the wire as JSON.

        This method is not to be used directly unless JSON must be process different.
        Methods `execute_dict` and `execute` have a more Pythonic result, and easier
        to use.

        Raises PortalAPIRequest when request with API or decoding result fails.
        &#34;&#34;&#34;
        headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;
        }

        if self.token:
            headers[&#39;Authorization&#39;] = &#39;Bearer &#39; + self.token

        url = self.api_url
        if isinstance(url, str):
            url = urlparse(self.api_url)

        req = Request(url.geturl(), headers=headers, method=&#39;POST&#39;, data=self.json())

        ssl_ctx = None
        if url.scheme == &#39;https&#39;:
            ssl_ctx = ssl.SSLContext()
            if environ.get(_ENV_SKIP_TLS_VERIFY):
                ssl_ctx.verify_mode = ssl.CERT_NONE

        try:
            return urlopen(req, context=ssl_ctx).read()
        except URLError as exc:
            raise PortalAPIRequest(str(exc.reason))

    def execute_dict(self) -&gt; dict:
        &#34;&#34;&#34;Executes the GraphQL request returning response as a dictionary.

        Raises `PortalAPIError` When the GraphQL API endpoint returned an error.
        When there was an issue with the request itself, or decoding JSON failed,
        the `PortalAPIRequest` exception is raised.
        &#34;&#34;&#34;
        res = self.execute_raw()
        if isinstance(res, bytes):
            res = res.decode(&#39;utf-8&#39;)

        try:
            response = json.loads(res, cls=GraphQLJSONDecoder)
        except json.JSONDecodeError as exc:
            raise PortalAPIRequest(&#34;failed decoding API response: &#34; + str(exc))

        try:
            first_error = response[&#39;errors&#39;][0]
        except (TypeError, KeyError, IndexError):
            # all is good; return response
            return response

        try:
            err = first_error[&#39;message&#39;]
            code = &#34;&#34;
            if &#39;extensions&#39; in first_error:
                if &#39;detail&#39; in first_error[&#39;extensions&#39;]:
                    err += &#39; (&#39; + first_error[&#39;extensions&#39;][&#39;detail&#39;] + &#39;)&#39;
                code = first_error[&#39;extensions&#39;].get(&#39;code&#39;, &#34;&#34;)
            g = Glosom(message=first_error[&#39;message&#39;], code=code)
        except KeyError as exc:
            raise PortalAPIRequest(f&#34;API request contained unusable error definition {exc}&#34;)
        except AttributeError:
            raise PortalAPIRequest(f&#34;API request contained unusable error extensions&#34;)
        else:
            raise PortalAPIError(glosom=g)

    def execute(self) -&gt; namedtuple:
        &#34;&#34;&#34;Executes the GraphQL request returning response as a namedtuple.

        This method wraps around the `execute` method, but returns instead of
        dict, a namedtuple which itself might contain namedtuples.

        Raises `PortalAPIError` When the GraphQL API endpoint returned an error.
        When there was an issue with the request itself, or decoding JSON failed,
        the `PortalAPIRequest` exception is raised.
        &#34;&#34;&#34;
        return graphql_data_to_namedtuple(self.execute_dict()[&#39;data&#39;])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dcso.portal.util.graphql.GraphQLRequest.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> <function namedtuple at 0x7fc607fdb830></span>
</code></dt>
<dd>
<div class="desc"><p>Executes the GraphQL request returning response as a namedtuple.</p>
<p>This method wraps around the <code>execute</code> method, but returns instead of
dict, a namedtuple which itself might contain namedtuples.</p>
<p>Raises <code>PortalAPIError</code> When the GraphQL API endpoint returned an error.
When there was an issue with the request itself, or decoding JSON failed,
the <code>PortalAPIRequest</code> exception is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; namedtuple:
    &#34;&#34;&#34;Executes the GraphQL request returning response as a namedtuple.

    This method wraps around the `execute` method, but returns instead of
    dict, a namedtuple which itself might contain namedtuples.

    Raises `PortalAPIError` When the GraphQL API endpoint returned an error.
    When there was an issue with the request itself, or decoding JSON failed,
    the `PortalAPIRequest` exception is raised.
    &#34;&#34;&#34;
    return graphql_data_to_namedtuple(self.execute_dict()[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="dcso.portal.util.graphql.GraphQLRequest.execute_dict"><code class="name flex">
<span>def <span class="ident">execute_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Executes the GraphQL request returning response as a dictionary.</p>
<p>Raises <code>PortalAPIError</code> When the GraphQL API endpoint returned an error.
When there was an issue with the request itself, or decoding JSON failed,
the <code>PortalAPIRequest</code> exception is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_dict(self) -&gt; dict:
    &#34;&#34;&#34;Executes the GraphQL request returning response as a dictionary.

    Raises `PortalAPIError` When the GraphQL API endpoint returned an error.
    When there was an issue with the request itself, or decoding JSON failed,
    the `PortalAPIRequest` exception is raised.
    &#34;&#34;&#34;
    res = self.execute_raw()
    if isinstance(res, bytes):
        res = res.decode(&#39;utf-8&#39;)

    try:
        response = json.loads(res, cls=GraphQLJSONDecoder)
    except json.JSONDecodeError as exc:
        raise PortalAPIRequest(&#34;failed decoding API response: &#34; + str(exc))

    try:
        first_error = response[&#39;errors&#39;][0]
    except (TypeError, KeyError, IndexError):
        # all is good; return response
        return response

    try:
        err = first_error[&#39;message&#39;]
        code = &#34;&#34;
        if &#39;extensions&#39; in first_error:
            if &#39;detail&#39; in first_error[&#39;extensions&#39;]:
                err += &#39; (&#39; + first_error[&#39;extensions&#39;][&#39;detail&#39;] + &#39;)&#39;
            code = first_error[&#39;extensions&#39;].get(&#39;code&#39;, &#34;&#34;)
        g = Glosom(message=first_error[&#39;message&#39;], code=code)
    except KeyError as exc:
        raise PortalAPIRequest(f&#34;API request contained unusable error definition {exc}&#34;)
    except AttributeError:
        raise PortalAPIRequest(f&#34;API request contained unusable error extensions&#34;)
    else:
        raise PortalAPIError(glosom=g)</code></pre>
</details>
</dd>
<dt id="dcso.portal.util.graphql.GraphQLRequest.execute_raw"><code class="name flex">
<span>def <span class="ident">execute_raw</span></span>(<span>self) ‑> ~AnyStr</span>
</code></dt>
<dd>
<div class="desc"><p>Executes the GraphQL query and return the response from the wire as JSON.</p>
<p>This method is not to be used directly unless JSON must be process different.
Methods <code>execute_dict</code> and <code>execute</code> have a more Pythonic result, and easier
to use.</p>
<p>Raises PortalAPIRequest when request with API or decoding result fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_raw(self) -&gt; AnyStr:
    &#34;&#34;&#34;Executes the GraphQL query and return the response from the wire as JSON.

    This method is not to be used directly unless JSON must be process different.
    Methods `execute_dict` and `execute` have a more Pythonic result, and easier
    to use.

    Raises PortalAPIRequest when request with API or decoding result fails.
    &#34;&#34;&#34;
    headers = {
        &#39;Content-Type&#39;: &#39;application/json&#39;
    }

    if self.token:
        headers[&#39;Authorization&#39;] = &#39;Bearer &#39; + self.token

    url = self.api_url
    if isinstance(url, str):
        url = urlparse(self.api_url)

    req = Request(url.geturl(), headers=headers, method=&#39;POST&#39;, data=self.json())

    ssl_ctx = None
    if url.scheme == &#39;https&#39;:
        ssl_ctx = ssl.SSLContext()
        if environ.get(_ENV_SKIP_TLS_VERIFY):
            ssl_ctx.verify_mode = ssl.CERT_NONE

    try:
        return urlopen(req, context=ssl_ctx).read()
    except URLError as exc:
        raise PortalAPIRequest(str(exc.reason))</code></pre>
</details>
</dd>
<dt id="dcso.portal.util.graphql.GraphQLRequest.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self) -&gt; bytes:
    q = self.query
    if self.fragments:
        q += &#39;\n&#39;.join(self.fragments)

    r = {
        &#39;query&#39;: q
    }

    if self.variables:
        r[&#39;variables&#39;] = self.variables

    return json.dumps(r, cls=GraphQLJSONEncoder).encode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://dcso.de">
<img src="https://avatars1.githubusercontent.com/u/17251161?s=200&v=4" width="52"> DCSO</a> Portal Python SDK
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dcso.portal.util" href="index.html">dcso.portal.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dcso.portal.util.graphql.graphql_data_to_namedtuple" href="#dcso.portal.util.graphql.graphql_data_to_namedtuple">graphql_data_to_namedtuple</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dcso.portal.util.graphql.GraphQLJSONDecoder" href="#dcso.portal.util.graphql.GraphQLJSONDecoder">GraphQLJSONDecoder</a></code></h4>
<ul class="">
<li><code><a title="dcso.portal.util.graphql.GraphQLJSONDecoder.object_hook" href="#dcso.portal.util.graphql.GraphQLJSONDecoder.object_hook">object_hook</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dcso.portal.util.graphql.GraphQLJSONEncoder" href="#dcso.portal.util.graphql.GraphQLJSONEncoder">GraphQLJSONEncoder</a></code></h4>
<ul class="">
<li><code><a title="dcso.portal.util.graphql.GraphQLJSONEncoder.default" href="#dcso.portal.util.graphql.GraphQLJSONEncoder.default">default</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dcso.portal.util.graphql.GraphQLRequest" href="#dcso.portal.util.graphql.GraphQLRequest">GraphQLRequest</a></code></h4>
<ul class="">
<li><code><a title="dcso.portal.util.graphql.GraphQLRequest.execute" href="#dcso.portal.util.graphql.GraphQLRequest.execute">execute</a></code></li>
<li><code><a title="dcso.portal.util.graphql.GraphQLRequest.execute_dict" href="#dcso.portal.util.graphql.GraphQLRequest.execute_dict">execute_dict</a></code></li>
<li><code><a title="dcso.portal.util.graphql.GraphQLRequest.execute_raw" href="#dcso.portal.util.graphql.GraphQLRequest.execute_raw">execute_raw</a></code></li>
<li><code><a title="dcso.portal.util.graphql.GraphQLRequest.json" href="#dcso.portal.util.graphql.GraphQLRequest.json">json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<div style="width: 100%; display: flex; justify-content: flex-end">
<div>
<p>Copyright (c) 2020, <a href="https://dcso.de">DCSO Deutsche Cyber-Sicherheitsorganisation GmbH</a></p>
</div>
<div>
<p><strong>v1.0.0-beta3</strong></p>
</div>
</div>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/dcso/dcso-portal-python-sdk" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</footer>
</body>
</html>